# 性能监控指南

**创建日期**: 2026-01-20  
**项目**: 历史年表网站  
**部署架构**: GitHub Pages（前端） + Vercel（后端 API）

---

## 📋 监控概述

性能监控是确保应用稳定性和用户体验的重要环节。本文档提供了多种监控方法，帮助你全面了解应用的性能状况。

---

## 🚀 1. Vercel Analytics

### 1.1 启用 Vercel Analytics

Vercel Analytics 提供了详细的性能指标和用户行为分析。

**启用步骤**：

1. **访问 Vercel Dashboard**
   ```
   https://vercel.com/dashboard
   ```

2. **选择项目**
   - 点击你的项目：timeline-app-one

3. **启用 Analytics**
   - 进入 "Analytics" 标签
   - 点击 "Enable Analytics"
   - 同意服务条款

4. **安装 Analytics SDK**

   在 `vercel.json` 中添加：

   ```json
   {
     "analytics": {
       "enabled": true
     }
   }
   ```

### 1.2 查看性能指标

**可用的指标**：

| 指标 | 说明 | 目标值 |
| ---- | ---- | ---- |
| Core Web Vitals | 核心网页指标 | 见下方 |
| LCP (Largest Contentful Paint) | 最大内容绘制时间 | < 2.5s |
| FID (First Input Delay) | 首次输入延迟 | < 100ms |
| CLS (Cumulative Layout Shift) | 累积布局偏移 | < 0.1 |
| TTFB (Time to First Byte) | 首字节时间 | < 600ms |
| FCP (First Contentful Paint) | 首次内容绘制 | < 1.8s |

**查看方式**：

1. 访问：https://vercel.com/analytics
2. 选择项目：timeline-app-one
3. 查看 "Performance" 标签
4. 选择时间范围：1h, 24h, 7d, 30d, 90d

### 1.3 查看用户行为

**可用的数据**：

- **页面浏览量**：每个页面的访问次数
- **唯一访客**：独立用户数量
- **地理位置**：用户分布
- **设备类型**：桌面/移动/平板
- **浏览器**：使用的浏览器
- **操作系统**：使用的操作系统
- **网络类型**：4G/5G/Wi-Fi

---

## 🌐 2. 浏览器开发者工具

### 2.1 Chrome DevTools

**打开方式**：
- Windows/Linux: `F12` 或 `Ctrl + Shift + I`
- Mac: `Cmd + Option + I`

#### 2.1.1 Performance 标签

**使用方法**：

1. 打开 Chrome DevTools
2. 切换到 "Performance" 标签
3. 点击 "Record" 按钮（或按 `Ctrl + E`）
4. 执行操作（如登录、加载收藏等）
5. 点击 "Stop" 按钮
6. 分析结果

**关键指标**：

| 指标 | 说明 | 目标值 |
| ---- | ---- | ---- |
| Total | 总执行时间 | < 3s |
| Scripting | JavaScript 执行时间 | < 500ms |
| Rendering | 渲染时间 | < 500ms |
| Painting | 绘制时间 | < 500ms |
| System | 系统时间 | < 200ms |
| Idle | 空闲时间 | 越多越好 |

#### 2.1.2 Network 标签

**使用方法**：

1. 打开 Chrome DevTools
2. 切换到 "Network" 标签
3. 刷新页面（`F5`）
4. 查看所有网络请求

**关键信息**：

| 列名 | 说明 | 目标值 |
| ---- | ---- | ---- |
| Name | 请求名称 | - |
| Status | HTTP 状态码 | 200/304 |
| Type | 资源类型 | - |
| Size | 请求大小 | 越小越好 |
| Time | 请求时间 | < 1s |
| Waterfall | 请求瀑布图 | 无阻塞 |

**优化建议**：

- **红色请求**：失败或超时
- **黄色请求**：较慢（> 500ms）
- **绿色请求**：正常（< 500ms）

#### 2.1.3 Lighthouse 标签

**使用方法**：

1. 打开 Chrome DevTools
2. 切换到 "Lighthouse" 标签
3. 选择 "Performance" 和 "Best Practices"
4. 点击 "Analyze page load"
5. 等待分析完成

**评分标准**：

| 分数 | 性能等级 |
| ---- | -------- |
| 90-100 | 优秀 |
| 75-89 | 良好 |
| 50-74 | 需要改进 |
| 0-49 | 较差 |

**优化建议**：

Lighthouse 会提供具体的优化建议，包括：
- 减少未使用的 JavaScript
- 优化图片
- 启用文本压缩
- 减少主线程工作
- 减少执行时间

---

## 📊 3. 自定义监控脚本

### 3.1 API 性能监控脚本

创建一个 API 性能监控脚本，记录所有 API 请求的响应时间。

**创建文件**：`api-performance-monitor.js`

```javascript
require('dotenv').config();

const API_BASE_URL = 'http://localhost:3000/api';

const performanceData = [];

async function monitorAPI(endpoint, method = 'GET', body = null) {
    const startTime = Date.now();
    
    try {
        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
            method,
            headers: {
                'Content-Type': 'application/json'
            },
            body: body ? JSON.stringify(body) : null
        });
        
        const duration = Date.now() - startTime;
        const data = await response.json();
        
        const record = {
            endpoint,
            method,
            status: response.status,
            duration,
            timestamp: new Date().toISOString(),
            success: response.ok
        };
        
        performanceData.push(record);
        
        console.log(`[${endpoint}] ${duration}ms - ${response.ok ? '✅' : '❌'}`);
        
        return { response, data, duration };
    } catch (error) {
        const duration = Date.now() - startTime;
        
        const record = {
            endpoint,
            method,
            status: 'ERROR',
            duration,
            timestamp: new Date().toISOString(),
            success: false,
            error: error.message
        };
        
        performanceData.push(record);
        
        console.log(`[${endpoint}] ${duration}ms - ❌ Error: ${error.message}`);
        
        throw error;
    }
}

function generateReport() {
    console.log('='.repeat(60));
    console.log('API 性能监控报告');
    console.log('='.repeat(60));
    console.log('');
    
    const totalRequests = performanceData.length;
    const successfulRequests = performanceData.filter(r => r.success).length;
    const failedRequests = totalRequests - successfulRequests;
    
    const durations = performanceData.map(r => r.duration);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);
    const minDuration = Math.min(...durations);
    
    const sortedDurations = [...durations].sort((a, b) => a - b);
    const p50 = sortedDurations[Math.floor(sortedDurations.length * 0.5)];
    const p95 = sortedDurations[Math.floor(sortedDurations.length * 0.95)];
    const p99 = sortedDurations[Math.floor(sortedDurations.length * 0.99)];
    
    console.log(`总请求数: ${totalRequests}`);
    console.log(`成功请求: ${successfulRequests} (${(successfulRequests / totalRequests * 100).toFixed(2)}%)`);
    console.log(`失败请求: ${failedRequests} (${(failedRequests / totalRequests * 100).toFixed(2)}%)`);
    console.log('');
    console.log(`平均响应时间: ${avgDuration.toFixed(2)}ms`);
    console.log(`最小响应时间: ${minDuration}ms`);
    console.log(`最大响应时间: ${maxDuration}ms`);
    console.log('');
    console.log(`P50 响应时间: ${p50}ms`);
    console.log(`P95 响应时间: ${p95}ms`);
    console.log(`P99 响应时间: ${p99}ms`);
    console.log('');
    
    const slowRequests = performanceData.filter(r => r.duration > 1000);
    if (slowRequests.length > 0) {
        console.log('慢请求 (> 1s):');
        slowRequests.forEach(r => {
            console.log(`  - ${r.endpoint}: ${r.duration}ms (${r.timestamp})`);
        });
        console.log('');
    }
    
    const failedRequestsList = performanceData.filter(r => !r.success);
    if (failedRequestsList.length > 0) {
        console.log('失败的请求:');
        failedRequestsList.forEach(r => {
            console.log(`  - ${r.endpoint}: ${r.error || r.status} (${r.timestamp})`);
        });
        console.log('');
    }
    
    console.log('='.repeat(60));
}

async function runTests() {
    console.log('开始 API 性能监控...');
    console.log('');
    
    // 测试登录
    await monitorAPI('/login', 'POST', {
        username: 'testuser',
        password: 'Test1234'
    });
    
    // 测试获取用户信息
    const loginResponse = await monitorAPI('/login', 'POST', {
        username: 'testuser',
        password: 'Test1234'
    });
    
    if (loginResponse.data.token) {
        await monitorAPI('/user?token=' + loginResponse.data.token);
    }
    
    // 测试获取收藏
    await monitorAPI('/favorites?token=' + loginResponse.data.token);
    
    // 生成报告
    generateReport();
}

runTests().catch(error => {
    console.error('监控脚本执行失败:', error);
    process.exit(1);
});
```

**运行方式**：

```bash
node api-performance-monitor.js
```

**输出示例**：

```
============================================================
API 性能监控报告
============================================================

总请求数: 4
成功请求: 4 (100.00%)
失败请求: 0 (0.00%)

平均响应时间: 523.50ms
最小响应时间: 215ms
最大响应时间: 1245ms

P50 响应时间: 432ms
P95 响应时间: 1245ms
P99 响应时间: 1245ms

慢请求 (> 1s):
  - /login: 1245ms (2026-01-20T12:00:00.000Z)

============================================================
```

---

### 3.2 前端性能监控

在前端代码中添加性能监控，记录页面加载时间和用户交互时间。

**修改文件**：`timeline-optimized.js`

在文件开头添加：

```javascript
const performanceMonitor = {
    metrics: [],
    
    startMeasure(name) {
        performance.mark(`${name}-start`);
    },
    
    endMeasure(name) {
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        
        const measure = performance.getEntriesByName(name)[0];
        const duration = measure.duration;
        
        this.metrics.push({
            name,
            duration,
            timestamp: new Date().toISOString()
        });
        
        console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);
        
        performance.clearMarks();
        performance.clearMeasures();
    },
    
    generateReport() {
        console.log('='.repeat(60));
        console.log('前端性能监控报告');
        console.log('='.repeat(60));
        console.log('');
        
        const pageLoad = performance.getEntriesByType('navigation')[0];
        if (pageLoad) {
            console.log('页面加载性能:');
            console.log(`  DOMContentLoaded: ${pageLoad.domContentLoadedEventEnd - pageLoad.domContentLoadedEventStart}ms`);
            console.log(`  Load Complete: ${pageLoad.loadEventEnd - pageLoad.loadEventStart}ms`);
            console.log(`  Total Load Time: ${pageLoad.loadEventEnd - pageLoad.fetchStart}ms`);
            console.log('');
        }
        
        const metrics = this.metrics;
        if (metrics.length > 0) {
            const durations = metrics.map(m => m.duration);
            const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
            const maxDuration = Math.max(...durations);
            const minDuration = Math.min(...durations);
            
            console.log(`自定义指标: ${metrics.length} 个`);
            console.log(`  平均: ${avgDuration.toFixed(2)}ms`);
            console.log(`  最小: ${minDuration.toFixed(2)}ms`);
            console.log(`  最大: ${maxDuration.toFixed(2)}ms`);
            console.log('');
            
            const slowMetrics = metrics.filter(m => m.duration > 1000);
            if (slowMetrics.length > 0) {
                console.log('慢操作 (> 1s):');
                slowMetrics.forEach(m => {
                    console.log(`  - ${m.name}: ${m.duration.toFixed(2)}ms`);
                });
            }
        }
        
        console.log('='.repeat(60));
    }
};

// 在页面加载完成后生成报告
window.addEventListener('load', () => {
    setTimeout(() => {
        performanceMonitor.generateReport();
    }, 1000);
});

// 使用示例
performanceMonitor.startMeasure('登录操作');
// ... 执行登录操作 ...
performanceMonitor.endMeasure('登录操作');
```

---

## 🗄️ 4. Supabase 监控

### 4.1 Supabase Dashboard

**访问方式**：

1. 访问：https://supabase.com/dashboard
2. 选择项目：sxjlazmnyrauiqqdjfah
3. 查看 "Database" 标签

### 4.2 数据库性能指标

**可用的指标**：

| 指标 | 说明 | 目标值 |
| ---- | ---- | ---- |
| Query Time | 查询时间 | < 100ms |
| Connection Time | 连接时间 | < 50ms |
| Active Connections | 活跃连接数 | < 10 |
| Cache Hit Rate | 缓存命中率 | > 80% |

### 4.3 查看慢查询

**步骤**：

1. 进入 Supabase Dashboard
2. 选择 "Database" 标签
3. 点击 "Logs" 或 "Query Stats"
4. 查看慢查询列表

**优化建议**：

- 添加索引到常用查询字段
- 优化复杂的 JOIN 查询
- 使用 LIMIT 限制返回结果
- 避免使用 SELECT *

---

## 📈 5. 性能优化建议

### 5.1 前端优化

**图片优化**：
- 使用 WebP 格式
- 压缩图片大小
- 实现懒加载

**代码优化**：
- 减少未使用的 JavaScript
- 压缩和合并 CSS/JS
- 使用代码分割

**缓存优化**：
- 启用浏览器缓存
- 使用 Service Worker
- 实现本地存储

### 5.2 后端优化

**数据库优化**：
- 添加索引
- 优化查询
- 使用连接池

**API 优化**：
- 实现缓存
- 减少响应大小
- 使用 CDN

**服务器优化**：
- 启用 Gzip 压缩
- 使用 Keep-Alive
- 优化静态资源

### 5.3 Vercel 优化

**配置优化**：
- 启用 Edge Functions
- 使用 Image Optimization
- 配置缓存策略

**部署优化**：
- 减少包大小
- 优化构建时间
- 使用增量部署

---

## 📋 6. 监控检查清单

### 每日检查

- [ ] 查看 Vercel Analytics
- [ ] 检查错误日志
- [ ] 查看慢请求
- [ ] 检查数据库性能

### 每周检查

- [ ] 分析性能趋势
- [ ] 优化慢查询
- [ ] 更新监控脚本
- [ ] 生成性能报告

### 每月检查

- [ ] 审查性能指标
- [ ] 制定优化计划
- [ ] 更新文档
- [ ] 培训团队成员

---

## 🔗 相关链接

### 监控工具

- **Vercel Analytics**: https://vercel.com/analytics
- **Supabase Dashboard**: https://supabase.com/dashboard
- **Chrome DevTools**: https://developer.chrome.com/docs/devtools
- **Lighthouse**: https://developers.google.com/web/tools/lighthouse

### 文档

- [项目追踪表](file:///e:\Program\test01\.trae\documents\项目追踪表.md)
- [部署状态总结](file:///e:\Program\test01\.trae\documents\部署状态总结.md)
- [Vercel冷启动优化实施总结](file:///e:\Program\test01\.trae\documents\Vercel冷启动优化实施总结.md)

---

## 🎯 下一步行动

### 1. 启用监控工具

- [ ] 启用 Vercel Analytics
- [ ] 配置 Supabase 监控
- [ ] 部署监控脚本

### 2. 建立基线

- [ ] 记录当前性能指标
- [ ] 设置性能目标
- [ ] 制定监控计划

### 3. 持续优化

- [ ] 定期检查性能
- [ ] 优化慢查询
- [ ] 改进用户体验

---

**创建日期**: 2026-01-20  
**项目状态**: 进行中（95% 完成）
